// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2538.PowerUp2538.subsystems;

import org.usfirst.frc2538.PowerUp2538.Robot;
import org.usfirst.frc2538.PowerUp2538.RobotMap;
import org.usfirst.frc2538.PowerUp2538.commands.*;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.wpilibj.ADXL345_I2C;
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class DriveTrain extends Subsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX talonSRX1 = RobotMap.driveTrainTalonSRX1;
    private final WPI_TalonSRX talonSRX3 = RobotMap.driveTrainTalonSRX3;
    private final DifferentialDrive differentialDrive1 = RobotMap.driveTrainDifferentialDrive1;
    private final WPI_TalonSRX centerMotor = RobotMap.driveTrainCenterMotor;
    private final DoubleSolenoid hUp = RobotMap.driveTrainhUp;
    private final WPI_TalonSRX talonSRX2 = RobotMap.driveTrainTalonSRX2;
    private final WPI_TalonSRX talonSRX4 = RobotMap.driveTrainTalonSRX4;
    private final DifferentialDrive differentialDrive2 = RobotMap.driveTrainDifferentialDrive2;
    private final AnalogInput rearRangeFinder = RobotMap.driveTrainRearRangeFinder;
    private final AnalogInput forwardRangeFinder = RobotMap.driveTrainforwardRangeFinder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private Joystick driveJoystick;
	public boolean hWheelIsUp = false;
	private int centerEncoderValue = 0;
	private int wheelEncoderValue = 0;
	private final ADXRS450_Gyro gyro = RobotMap.gyro;
	private final ADXL345_I2C accelerometer = RobotMap.accelerometer;
	private final double distanceToWall = 8;
	private final Timer timer = new Timer();
	private boolean delayed = false;
	private double delayTime = 2.0;
	private boolean moveAfterDelay = false;
	private double tooCloseForComfort = 1.2;
	private double gyroAngle;
	private final double tolerance=3.0;
	private final double scaleAdjust=0.02;
	public final int hWheelCountsPerFt = 9750;
	public final int mainWheelCountsPerFt = 2200;
	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DriveCommand());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
		driveJoystick = Robot.oi.getJoystick1();
		gyroAngle=RobotMap.gyro.getAngle();
	}

	private int counter = 0;

	public void drive() {
		counter++;
		double y = driveJoystick.getY();
		double x = driveJoystick.getX();
		double z = driveJoystick.getZ();
		String s = "Now Moving " + x + " " + z + " counter = " + counter;
		SmartDashboard.putString("Drive train", s);
		differentialDrive1.arcadeDrive(y, +z);
		differentialDrive2.arcadeDrive(y, +z);
		centerMotor.set(x);
		findRearDistance();

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void hWheelUp() {
		hUp.set(DoubleSolenoid.Value.kReverse);
		hWheelIsUp = true;
		SmartDashboard.putBoolean("H wheel is up", hWheelIsUp);
	}

	public void hWheelDown() {
		hUp.set(DoubleSolenoid.Value.kForward);
		hWheelIsUp = false;
		SmartDashboard.putBoolean("H wheel is up", hWheelIsUp);

	}

	public boolean saveEncoderValues() {
		centerEncoderValue = centerMotor.getSensorCollection().getQuadraturePosition();
		wheelEncoderValue = talonSRX1.getSensorCollection().getQuadraturePosition();
		SmartDashboard.putString("encoder start value", centerEncoderValue + "  " + wheelEncoderValue);
		return true;

	}
	
	private double x;
	private double y;
	private double width;
	public void setXYWidth(double x, double y,double width){
		this.x = x;
		this.y = y;
		this.width = width;
	}

	public boolean driveAngle() {
		// TODO: make sure we are not pausing at the switch
		double encoderValue = centerMotor.getSensorCollection().getQuadraturePosition();
		if (delayed && timer.get() < delayTime) {
			differentialDrive1.arcadeDrive(0, 0);
			differentialDrive2.arcadeDrive(0,0);
			SmartDashboard.putBoolean("delayed", delayed);
			return false;
		} else if (delayed && timer.get() >= delayTime) {
			moveAfterDelay = true;
			SmartDashboard.putBoolean("delayed", delayed);
			SmartDashboard.putBoolean("move after delay", moveAfterDelay);
			return false;
		} else if (!moveAfterDelay && getForwardRange() <= tooCloseForComfort) {
			timer.reset();
			timer.start();
			delayed = true;
			SmartDashboard.putString("obstacle", "yes");
			return false;
		} else if (encoderValue < centerEncoderValue + width) {				
			double adjScale = getGyroAdjustments();
			differentialDrive1.arcadeDrive(x, adjScale);
			differentialDrive2.arcadeDrive(x, adjScale);
			centerMotor.set(y*adjScale);
			SmartDashboard.putNumber("h wheel encoder", encoderValue);
			return false;
		} else {
			differentialDrive1.arcadeDrive(0, 0);
			differentialDrive2.arcadeDrive(0,0);
			centerMotor.set(0);
			return true;
		}
	}
	
	public boolean driveAngleNoMatterWhat() {
		double encoderValue = centerMotor.getSensorCollection().getQuadraturePosition();
		 if (Math.abs(encoderValue - centerEncoderValue) < width) {				
			double adjScale = getGyroAdjustments();
			differentialDrive1.arcadeDrive(x, adjScale);
			differentialDrive2.arcadeDrive(x, adjScale);
			centerMotor.set(y);
			SmartDashboard.putNumber("h wheel encoder", encoderValue);
			return false;
		} else {
			differentialDrive1.arcadeDrive(0, 0);
			differentialDrive2.arcadeDrive(0,0);
			centerMotor.set(0);
			return true;
		}
	}
	
	public boolean needToContinue(){
		return (delayed||moveAfterDelay);
	}

	public boolean driveStraight(double x, double length) {
			double encoderValue = talonSRX1.getSensorCollection().getQuadraturePosition();
			SmartDashboard.putNumber("Drive motor encoder", encoderValue);
			double rangeFinderValue = findRearDistance();
			SmartDashboard.putNumber("Range finder to the wall",  rangeFinderValue);
			//if (rangeFinderValue <= distanceToWall && encoderValue < wheelEncoderValue + length) {
			if (Math.abs(encoderValue - centerEncoderValue) < length) {
				double adjScale = getGyroAdjustments();
				differentialDrive1.arcadeDrive(x, adjScale);
				differentialDrive2.arcadeDrive(x, adjScale);

				SmartDashboard.putString("Moving forward", "yes");
				return false;
			} else {
				differentialDrive1.arcadeDrive(0, 0);
				differentialDrive2.arcadeDrive(0,0);
				//SmartDashboard.putString("Wall detected", "yes");
				SmartDashboard.putString("Length reached", "yes");
				return true;
			}
		//}
	}
	
	public void initAutoVariables(){
		delayed = false;
		moveAfterDelay = false;
	}

	public void stopHWheel() {
		centerMotor.set(0);
	}

	public double findRearDistance() {
		double rv = rearRangeFinder.getVoltage();
		SmartDashboard.putNumber("GyroAngle",gyro.getAngle());
		SmartDashboard.putNumber("range finder voltage", rv);
		/*
		 * rv= gyro.getAngle(); SmartDashboard.putNumber("Gyro angle", rv); rv=
		 * accelerometer.getX();
		 * SmartDashboard.putNumber("accelerometer X axis", rv); rv=
		 * accelerometer.getY();
		 * SmartDashboard.putNumber("accelerometer Y axis", rv); rv=
		 * accelerometer.getZ();
		 * SmartDashboard.putNumber("accelerometer Z axis", rv);
		 */
		int ecv = talonSRX3.getSensorCollection().getQuadraturePosition();
		SmartDashboard.putNumber(" ecoder", ecv);
		ecv = centerMotor.getSensorCollection().getQuadraturePosition();
		SmartDashboard.putNumber("H wheel encoder", ecv);
		return rv;
	}

	private double getForwardRange() {
		return forwardRangeFinder.getVoltage();
	}
	
	private double getGyroAdjustments() {
		double g1 = RobotMap.gyro.getAngle() * 1.0001;
		// SmartDashboard.putString("encoder",
		// Double.toString(g1-g0).substring(0, 6));
		if (Math.abs(g1 - gyroAngle) > tolerance) {
			/*if (g1 > gyroAngle) {
				leftScale *=1+(scaleAdjust);
				rightScale *=1-(scaleAdjust);
			} else if (g1 < gyroAngle) {
				rightScale *=1+(scaleAdjust);
				leftScale *=1-(scaleAdjust);
			}*/
			return -scaleAdjust*(g1 - gyroAngle);
		}
		
		return 0; // passed to the z rotation
	}
	
	public void setGyroAngle() {
		gyroAngle = RobotMap.gyro.getAngle();
	}
	
	public boolean turn(double z){
		if(Math.abs(RobotMap.gyro.getAngle()-gyroAngle)<90) {
			differentialDrive1.arcadeDrive(0, z);
			differentialDrive2.arcadeDrive(0, z);
			centerMotor.set(0);
			SmartDashboard.putNumber("auto turn",RobotMap.gyro.getAngle()-gyroAngle);
			return false;
		}else{
			differentialDrive1.arcadeDrive(0, 0);
			differentialDrive2.arcadeDrive(0, 0);
			centerMotor.set(0);
			return true;
		}
			
	
	}
	
	public void stop() {
		differentialDrive1.arcadeDrive(0, 0);
		differentialDrive2.arcadeDrive(0, 0);
		centerMotor.set(0);
	}
	public double getEncoder(){
		return talonSRX1.getSensorCollection().getQuadraturePosition();
	}
	
}
