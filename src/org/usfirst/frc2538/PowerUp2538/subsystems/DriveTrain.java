// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2538.PowerUp2538.subsystems;

import org.usfirst.frc2538.PowerUp2538.Robot;
import org.usfirst.frc2538.PowerUp2538.RobotMap;
import org.usfirst.frc2538.PowerUp2538.commands.*;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.wpilibj.ADXL345_I2C;
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class DriveTrain extends Subsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX talonSRX1 = RobotMap.driveTrainTalonSRX1;
    private final WPI_TalonSRX talonSRX3 = RobotMap.driveTrainTalonSRX3;
    private final DifferentialDrive differentialDrive1 = RobotMap.driveTrainDifferentialDrive1;
    private final WPI_TalonSRX centerMotor = RobotMap.driveTrainCenterMotor;
    private final DoubleSolenoid hUp = RobotMap.driveTrainhUp;
    private final WPI_TalonSRX talonSRX2 = RobotMap.driveTrainTalonSRX2;
    private final WPI_TalonSRX talonSRX4 = RobotMap.driveTrainTalonSRX4;
    private final DifferentialDrive differentialDrive2 = RobotMap.driveTrainDifferentialDrive2;
    private final AnalogInput rearRangeFinder = RobotMap.driveTrainRearRangeFinder;
    private final AnalogInput forwardRangeFinder = RobotMap.driveTrainforwardRangeFinder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private Joystick driveJoystick;
	public boolean hWheelIsUp = false;
	private int centerEncoderValue = 0;
	private int wheelEncoderValue = 0;
	private final ADXRS450_Gyro gyro = RobotMap.gyro;
	private final ADXL345_I2C accelerometer = RobotMap.accelerometer;
	private final double distanceToWall = 8;
	private final Timer timer = new Timer();
	private boolean delayed = false;
	private double delayTime = 2.0;
	private boolean moveAfterDelay = false;
	private double tooCloseForComfort = 1.2;
	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DriveCommand());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
		driveJoystick = Robot.oi.getJoystick1();
	}

	private int counter = 0;

	public void drive() {
		counter++;
		double y = driveJoystick.getY();
		double x = driveJoystick.getX();
		double z = driveJoystick.getZ();
		String s = "Now Moving " + x + " " + z + " counter = " + counter;
		SmartDashboard.putString("Drive train", s);
		differentialDrive1.arcadeDrive(y, +z);
		differentialDrive2.arcadeDrive(y, +z);
		centerMotor.set(x);
		findRearDistance();

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void hWheelUp() {
		hUp.set(DoubleSolenoid.Value.kReverse);
		hWheelIsUp = true;
		SmartDashboard.putBoolean("H wheel is up", hWheelIsUp);
	}

	public void hWheelDown() {
		hUp.set(DoubleSolenoid.Value.kForward);
		hWheelIsUp = false;
		SmartDashboard.putBoolean("H wheel is up", hWheelIsUp);

	}

	public boolean saveEncoderValues() {
		centerEncoderValue = centerMotor.getSensorCollection().getQuadraturePosition();
		wheelEncoderValue = talonSRX1.getSensorCollection().getQuadraturePosition();
		SmartDashboard.putString("encoder start value", centerEncoderValue + "  " + wheelEncoderValue);
		return true;

	}

	public boolean driveAngle(double x, double y, double width) {
		// TODO: make sure we are not pausing at the switch
		double encoderValue = centerMotor.getSensorCollection().getQuadraturePosition();
		if (delayed && timer.get() < delayTime) {
			differentialDrive1.arcadeDrive(0, 0);
			SmartDashboard.putBoolean("delayed", delayed);
			return false;
		} else if (delayed && timer.get() >= delayTime) {
			moveAfterDelay = true;
			SmartDashboard.putBoolean("delayed", delayed);
			SmartDashboard.putBoolean("move after delay", moveAfterDelay);
			return false;
		} else if (!moveAfterDelay && getForwardRange() <= tooCloseForComfort) {
			timer.reset();
			timer.start();
			delayed = true;
			SmartDashboard.putString("obstacle", "yes");
			return false;
		} else if (encoderValue < centerEncoderValue + width) {
			differentialDrive1.arcadeDrive(x, 0);
			centerMotor.set(y);
			SmartDashboard.putNumber("h wheel encoder", encoderValue);
			return false;
		} else {
			differentialDrive1.arcadeDrive(0, 0);
			centerMotor.set(0);
			return true;
		}
	}
	
	public boolean driveAngleNoMatterWhat(double x, double y, double width) {
		double encoderValue = centerMotor.getSensorCollection().getQuadraturePosition();
		 if (encoderValue < centerEncoderValue + width) {
			differentialDrive1.arcadeDrive(x, 0);
			centerMotor.set(y);
			SmartDashboard.putNumber("h wheel encoder", encoderValue);
			return false;
		} else {
			differentialDrive1.arcadeDrive(0, 0);
			centerMotor.set(0);
			return true;
		}
	}
	
	public boolean needToContinue(){
		return (delayed||moveAfterDelay);
	}

	public boolean driveStraight(double x, double length) {
//		if (delayed && timer.get() < delayTime) {
//			differentialDrive1.arcadeDrive(0, 0);
//			SmartDashboard.putBoolean("delayed", delayed);
//			return false;
//		} else if (delayed && timer.get() >= delayTime) {
//			moveAfterDelay = true;
//			SmartDashboard.putBoolean("delayed", delayed);
//			SmartDashboard.putBoolean("move after delay", moveAfterDelay);
//			return false;
//		} else if (!moveAfterDelay && getForwardRange() <= tooCloseForComfort) {
//			timer.reset();
//			timer.start();
//			delayed = true;
//			SmartDashboard.putString("obstacle", "yes");
//			return false;
//		} else {
			double encoderValue = talonSRX3.getSensorCollection().getQuadraturePosition();
			if (findRearDistance() <= distanceToWall && encoderValue < wheelEncoderValue + length) {
				differentialDrive1.arcadeDrive(x, 0);
				SmartDashboard.putNumber("not h wheel encoder", encoderValue);
				SmartDashboard.putString("Moving forward", "yes");
				return false;
			} else {
				differentialDrive1.arcadeDrive(0, 0);
				SmartDashboard.putString("Wall detected", "yes");
				return true;
			}
		//}
	}
	
	public void initAutoVariables(){
		delayed = false;
		moveAfterDelay = false;
	}

	public void stopHWheel() {
		centerMotor.set(0);
	}

	public double findRearDistance() {
		double rv = rearRangeFinder.getVoltage() * 3.461 - 0.136;
		SmartDashboard.putNumber("range finder voltage", rv);
		/*
		 * rv= gyro.getAngle(); SmartDashboard.putNumber("Gyro angle", rv); rv=
		 * accelerometer.getX();
		 * SmartDashboard.putNumber("accelerometer X axis", rv); rv=
		 * accelerometer.getY();
		 * SmartDashboard.putNumber("accelerometer Y axis", rv); rv=
		 * accelerometer.getZ();
		 * SmartDashboard.putNumber("accelerometer Z axis", rv);
		 */
		int ecv = talonSRX3.getSensorCollection().getQuadraturePosition();
		SmartDashboard.putNumber(" ecoder", ecv);
		ecv = centerMotor.getSensorCollection().getQuadraturePosition();
		SmartDashboard.putNumber("H wheel encoder", ecv);
		return rv;
	}

	private double getForwardRange() {
		return forwardRangeFinder.getVoltage() * 3.461 - 0.136;
	}
}
